<html>

<head>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <style>
    body {
      font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
      margin-left: 40px;
    }

    .borough {
      fill: #e7eef3;
      stroke: #2c3e50;
      stroke-width: 1px;
    }

    .dot {
      fill: #036ffc;
      opacity: 0.7;
    }

    .highlighted {
      fill: #b5c9cf;
      stroke: #2c3e50;
      stroke-width: 2px;
    }

    .tooltip {
      position: absolute;
      visibility: hidden;
      padding: 5px;
      background-color: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      white-space: nowrap;
    }

    .title {
      font-size: 20px;
      font-weight: bold;
      margin-top: 50px;
      margin-bottom: 10px;
    }

    .subtitle {
      margin-bottom: 20px;
    }

    select {
      margin-top: 10px;
      margin-bottom: 10px;
    }

    .container {
      display: flex;
      align-items: flex-start;
      margin-top: 10px;
    }

    #nyc-map {
      width: 800px;
      height: 600px;
      flex-shrink: 0;
      margin-right: 20px;
    }

    .filters-sidebar {
      width: 400px; 
      height: 550px;
      display: flex;
      flex-direction: column;
      padding: 15px;
      background-color: #f8f9fa;
      box-shadow: -2px 0 5px rgba(0, 0, 0, 0.1);
      overflow-y: auto;
}

    #time-controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 10px;
    }

    #time-controls label {
      margin-right: 10px;
      padding-top: 10px;
    }

    .slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .slider-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-top: 5px; 
}

  </style>
</head>

<body>
  <div class="title">NYC Traffic Accidents in 2022</div>
  <div class="subtitle">Interactive map showing total accidents that happened in each borough</div>
  <div id="container" style="display: flex; height: 100vh;">
    <div style="flex-grow: 1;">
      <svg id="nyc-map" height="600" width="800"></svg>
    </div>

    <div id="controls-traffic"
  style="width: 500px; height: 550px; padding: 15px; overflow-y: auto; background-color: #f8f9fa; box-shadow: -2px 0 5px rgba(0, 0, 0, 0.1);">
  <div>
    <label>Select Borough: </label>
    <select id="borough-select">
      <option value="all">All</option>
    </select>
  </div>
  <div>
    <label>Select Vehicle Type: </label>
    <select id="vehicle-type-select">
      <option value="all">All</option>
    </select>
  </div>
  <div class="slider-container">
    <label for="range-slider">Accident Range:</label>
    <div class="slider-wrapper">
      <svg id="range-slider" width="280" height="50"></svg>
      <span id="range-values" class="range-text">Range: 25 - 100</span>
    </div>
  </div>
  <div id="time-controls">
    <div class="slider-container">
      <label for="time-slider">Time of Day:</label>
      <input type="range" id="time-slider" min="0" max="23" value="0">
      <span id="time-value">12 AM</span>
    </div>
    <div class="slider-container">
      <label for="day-slider">Day of Week:</label>
      <input type="range" id="day-slider" min="0" max="6" value="0">
      <span id="day-value">Sunday</span>
    </div>
    <div class="slider-container">
      <label for="month-slider">Month:</label>
      <input type="range" id="month-slider" min="0" max="11" value="0">
      <span id="month-value">January</span>
    </div>
  </div>
</div>
</div>


  <div class="title">Traffic Congestion by Borough in 2022</div>
  <div class="subtitle">Bar chart showing congestion levels for each borough by selected time</div>
  <!-- <div id="controls-congestion">
    <div>
      <label for="date-picker">Select a Date: </label>
      <input type="date" id="date-picker">
    </div>
  </div> -->
  <div>
    <label for="borough-selector">Select Borough:</label>
    <select id="borough-selector">
      <option value="All">All Boroughs</option>
    </select>
    <input type="month" id="date-picker">
  </div>
  <svg id="chart" width="900" height="500"></svg>


  </div>

  <script>
    const svg = d3.select("#nyc-map");
    const width = svg.attr("width");
    const height = svg.attr("height");
    let selectedTime = 0;
    let selectedDay = 0;
    let selectedMonth = 0;
    let selectedBoroughPath;
    const daysOfWeek = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    const months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    const parseDateTime = d3.timeParse("%Y-%m-%d %H:%M:%S");

    const sliderSvg = d3.select("#range-slider");
    const sliderWidth = sliderSvg.attr("width");
    const sliderHeight = sliderSvg.attr("height");
    const sliderMargin = 20;
    const sliderMin = 0;
    const sliderMax = 525;
    let minAccidents = 25;
    let maxAccidents = 100;

    const xScale = d3.scaleLinear()
      .domain([sliderMin, sliderMax])
      .range([sliderMargin, sliderWidth - sliderMargin])
      .clamp(true);

    sliderSvg.append("line")
      .attr("x1", xScale(sliderMin))
      .attr("x2", xScale(sliderMax))
      .attr("y1", sliderHeight / 2)
      .attr("y2", sliderHeight / 2)
      .attr("stroke", "#ccc")
      .attr("stroke-width", 5);

    const render = async () => {
      const boroughs = await d3.json('nyc_boroughs.topo.json');
      console.log(boroughs)
      const boroughsFeature = topojson.feature(boroughs, boroughs.objects.nyc_boroughs);
      console.log(boroughsFeature)

      const collisions = await d3.csv('NYC_Collisions.csv');

      const projection = d3.geoMercator()
        .fitSize([width, height], boroughsFeature);

      const path = d3.geoPath().projection(projection);

      d3.select("#borough-select")
        .selectAll("option.borough-option")
        .data(boroughsFeature.features)
        .join("option")
        .attr("class", "borough-option")
        .attr("value", d => d.properties.boro_name)
        .text(d => d.properties.boro_name);

      svg.selectAll(".borough")
        .data(boroughsFeature.features)
        .join("path")
        .attr("class", "borough")
        .attr("d", path)
        .on("click", function (event, d) {
          zoomToBorough(d);
        });

      const vehicleTypes = [...new Set(collisions.map(d => d['Vehicle Type']))];
      d3.select("#vehicle-type-select")
        .selectAll("option.vehicle-option")
        .data(vehicleTypes)
        .join("option")
        .attr("class", "vehicle-option")
        .attr("value", d => d)
        .text(d => d);

      const tooltip = d3.select("#tooltip");

      const updateAccidents = () => {
        const selectedVehicleType = d3.select("#vehicle-type-select").property("value");
        const selectedBorough = d3.select("#borough-select").property("value");
        const filteredCollisions = collisions.filter(d => {
          const dateTimeString = `${d['Date']} ${d['Time']}`;
          const accidentTime = parseDateTime(dateTimeString);
          if (!accidentTime) return false;
          const hour = accidentTime.getHours();
          const day = accidentTime.getDay();
          const month = accidentTime.getMonth();
          return (
            (selectedVehicleType === 'all' || d['Vehicle Type'] === selectedVehicleType) &&
            (hour === selectedTime ||
              day === selectedDay ||
              month === selectedMonth) && (
              (selectedBorough === 'all' || d.Borough === selectedBorough))
          );
        });

        const accidentCounts = d3.rollups(
          filteredCollisions,
          v => v.length,
          d => d['Street Name']
        ).filter(([_, count]) => count >= minAccidents && count <= maxAccidents);

        const accidentsWithCoords = accidentCounts.map(([street, count]) => {
          const point = filteredCollisions.find(d => d['Street Name'] === street);
          if (point && point.Latitude && point.Longitude) {
            return {
              street: street,
              count: count,
              coordinates: [point.Longitude, point.Latitude],
              borough: point.Borough
            };
          }
        }).filter(d => d && d.count && d.coordinates);

        const dots = svg.selectAll(".dot")
          .data(accidentsWithCoords, d => d.street);

        dots.join("circle")
          .attr("class", "dot")
          .attr("cx", d => projection(d.coordinates)[0])
          .attr("cy", d => projection(d.coordinates)[1])
          .attr("r", d => Math.sqrt(d.count))
          .on("mouseover", function (event, d) {
            d3.select(this).style("fill", "#25d6fa");
            tooltip.style("visibility", "visible")
              .text(`Accidents: ${d.count}, Street: ${d.street}`);
          })
          .on("mousemove", function (event) {
            tooltip.style("top", `${event.pageY + 10}px`)
              .style("left", `${event.pageX + 10}px`);
          })
          .on("mouseout", function () {
            d3.select(this).style("fill", "#036ffc");
            tooltip.style("visibility", "hidden");
          });

        dots.transition()
          .attr("cx", d => projection(d.coordinates)[0])
          .attr("cy", d => projection(d.coordinates)[1])
          .attr("r", d => Math.sqrt(d.count));

        dots.exit().remove();
      };

      d3.select("#vehicle-type-select").on("change", () => {
        updateAccidents();
      });

      d3.select("#time-slider").on("input", function () {
        selectedTime = +this.value;
        console.log(selectedTime)
        d3.select("#time-value").text(`${selectedTime % 12 === 0 ? 12 : selectedTime % 12} ${selectedTime < 12 ? "AM" : "PM"}`);
        updateAccidents();
      });

      d3.select("#day-slider").on("input", function () {
        selectedDay = +this.value;
        d3.select("#day-value").text(daysOfWeek[selectedDay]);
        updateAccidents();
      });

      d3.select("#month-slider").on("input", function () {
        selectedMonth = +this.value;
        d3.select("#month-value").text(months[selectedMonth]);
        updateAccidents();
      });

      const zoom = d3.zoom().on("zoom", (event) => {
        svg.selectAll('path').attr('transform', event.transform);
        svg.selectAll('circle').attr('transform', event.transform);
      });

      svg.call(zoom);

      const zoomToBorough = (borough, boroughPath) => {
        const [[x0, y0], [x1, y1]] = path.bounds(borough);
        const scale = 0.8 / Math.max((x1 - x0) / width, (y1 - y0) / height);
        const translate = [
          width / 2 - scale * (x0 + x1) / 2,
          height / 2 - scale * (y0 + y1) / 2
        ];

        svg.transition().duration(750).call(
          zoom.transform,
          d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
        );

        if (selectedBoroughPath) {
          selectedBoroughPath.classed("highlighted", false);
        }
        selectedBoroughPath = boroughPath;
        selectedBoroughPath.classed("highlighted", true);

        const boroughName = borough.properties.boro_name;
        svg.selectAll(".dot")
          .style("visibility", d => d.borough === boroughName ? "visible" : "hidden");
      };

      d3.select("#borough-select").on("change", function () {
        const selectedBorough = this.value;
        if (selectedBorough === "all") {
          svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
          svg.selectAll(".dot").style("visibility", "visible");
          if (selectedBoroughPath) {
            selectedBoroughPath.classed("highlighted", false);
            selectedBoroughPath = null;
          }
        } else {
          const borough = boroughsFeature.features.find(b => b.properties.boro_name === selectedBorough);
          const boroughPath = svg.selectAll(".borough").filter(d => d.properties.boro_name === selectedBorough);
          if (borough) zoomToBorough(borough, boroughPath);
        }
        updateAccidents();
      });

      const handleMin = sliderSvg.append("circle")
        .attr("cx", xScale(minAccidents))
        .attr("cy", sliderHeight / 2)
        .attr("r", 8)
        .attr("fill", "#036ffc")
        .attr("class", "slider-handle")
        .call(d3.drag()
          .on("drag", function (event) {
            const newValue = Math.round(xScale.invert(event.x));
            if (newValue < maxAccidents && newValue >= sliderMin) {
              minAccidents = newValue;
              console.log(`new min: ${minAccidents}`)
              d3.select(this).attr("cx", xScale(minAccidents));
              updateRangeValues();
              updateAccidents();
            }
          }));

      const handleMax = sliderSvg.append("circle")
        .attr("cx", xScale(maxAccidents))
        .attr("cy", sliderHeight / 2)
        .attr("r", 8)
        .attr("fill", "#036ffc")
        .attr("class", "slider-handle")
        .call(d3.drag()
          .on("drag", function (event) {
            const newValue = Math.round(xScale.invert(event.x));
            if (newValue > minAccidents && newValue <= sliderMax) {
              maxAccidents = newValue;
              console.log(`new max: ${maxAccidents}`)
              d3.select(this).attr("cx", xScale(maxAccidents));
              updateRangeValues();
              updateAccidents();
            }
          }));

      const updateRangeValues = () => {
        d3.select("#range-values").text(`Range: ${minAccidents} - ${maxAccidents}`);
      };

      updateRangeValues();
      updateAccidents();
    };

    render();
  </script>

  <!-- <script>
    const svg2 = d3.select("#chart");
    const margin = { top: 50, right: 30, bottom: 70, left: 60 };
    const width2 = svg2.attr("width") - margin.left - margin.right;
    const height2 = svg2.attr("height") - margin.top - margin.bottom;

    const g = svg2.append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

    const tooltip = d3.select("body")
      .append("div")
      .attr("id", "tooltip")
      .attr("class", "tooltip");

    const render2 = async () => {
      const volumeData = await d3.csv("Volume_Counts.csv");
      const accidentData = await d3.csv("NYC_Collisions.csv");

      volumeData.forEach(d => {
        const year = d.Yr;
        const month = d.M.padStart(2, "0");
        const day = d.D.padStart(2, "0");
        d.Date = `${year}-${month}-${day}`;
        d.Vol = +d.Vol;
      });

      const aggregatedVolume = d3.rollups(
        volumeData,
        v => d3.sum(v, d => d.Vol),
        d => d.Boro,
        d => d.Date
      );

      const aggregatedAccidents = d3.rollups(
        accidentData,
        v => v.length,
        d => d.Borough,
        d => d.Date
      );

      console.log(aggregatedVolume)
      console.log(aggregatedAccidents)

      const boroughs = Array.from(new Set(volumeData.map(d => d.Boro)));
      const dates = Array.from(new Set(volumeData.map(d => d.Date))).sort();

      const combinedData = boroughs.map(borough => {
        const data = dates.map(date => {
          const volumeEntry = aggregatedVolume.find(([b, d]) => {
            if (b === borough && Array.isArray(d)) {
              return d.some(dateData => dateData[0] === date);
            }
            return false;
          });

          const congestion = volumeEntry
            ? (volumeEntry[1].find(dateData => dateData[0] === date) || [])[1] || 0
            : 0;

          const accidentEntry = aggregatedAccidents.find(([b, h]) => {
            if (b === borough && Array.isArray(h)) {
              return h.some(dateData => dateData[0] === date);
            }
            return false;
          });

          const accidents = accidentEntry
            ? (accidentEntry[1].find(dateData => dateData[0] === date) || [])[1] || 0
            : 0;

          return { date, congestion, accidents };
        });
        return { borough, data };
      });

      console.log(combinedData)

      d3.select("#date-picker")
        .attr("min", dates[0])
        .attr("max", dates[dates.length - 1])
        .property("value", dates[0]);

      const xScale = d3.scaleBand()
        .domain(boroughs)
        .range([10, width2])
        .padding(0.2);

      const xSubScale = d3.scaleBand()
        .domain(["Congestion", "Accidents"])
        .range([0, xScale.bandwidth()])
        .padding(0.1);

      const yScale = d3.scaleLinear()
        .range([height2, 0]);

      const xAxis = g.append("g")
        .attr("transform", `translate(0, ${height2})`)
        .call(d3.axisBottom(xScale));

      const yAxis = g.append("g")
        .call(d3.axisLeft(yScale));

      g.append("text")
        .attr("class", "axis-label")
        .attr("x", width2 / 2)
        .attr("y", height2 + margin.bottom - 15)
        .attr("text-anchor", "middle")
        .text("Borough");

      g.append("text")
        .attr("class", "axis-label")
        .attr("x", -height2 / 2)
        .attr("y", -margin.left + 12)
        .attr("transform", "rotate(-90)")
        .attr("text-anchor", "middle")
        .text("Volume of Cars");

      const updateChart = selectedDate => {
        const scalingFactor = 100;
        const filteredData = combinedData.map(({ borough, data }) => {
          const dateData = data.find(d => d.date === selectedDate) || {};
          return {
            borough,
            congestion: (dateData.congestion || 0) / scalingFactor,
            accidents: dateData.accidents || 0
          };
        });

        yScale.domain([0, d3.max(filteredData, d => Math.max(d.congestion, d.accidents))]);

        yAxis.transition().call(d3.axisLeft(yScale).ticks(5));

        const groups = g.selectAll(".bar-group")
          .data(filteredData, d => d.borough);

        const enterGroups = groups.enter()
          .append("g")
          .attr("class", "bar-group")
          .attr("transform", d => `translate(${xScale(d.borough)}, 0)`);

        enterGroups.append("rect")
          .merge(groups.select(".congestion-bar"))
          .attr("class", "bar congestion-bar")
          .attr("x", d => xSubScale("Congestion"))
          .attr("y", d => yScale(d.congestion))
          .attr("width", xSubScale.bandwidth())
          .attr("height", d => height2 - yScale(d.congestion))
          .attr("fill", "#1f77b4")
          .on("mouseover", (event, d) => {
            tooltip.style("visibility", "visible")
              .text(`Congestion (scaled): ${d.congestion * scalingFactor}`);
          })
          .on("mousemove", event => {
            tooltip.style("top", `${event.pageY + 10}px`).style("left", `${event.pageX + 10}px`);
          })
          .on("mouseout", () => {
            tooltip.style("visibility", "hidden");
          });

        enterGroups.append("rect")
          .merge(groups.select(".accidents-bar"))
          .attr("class", "bar accidents-bar")
          .attr("x", d => xSubScale("Accidents"))
          .attr("y", d => yScale(d.accidents))
          .attr("width", xSubScale.bandwidth())
          .attr("height", d => height2 - yScale(d.accidents))
          .attr("fill", "#d62728")
          .on("mouseover", (event, d) => {
            tooltip.style("visibility", "visible")
              .text(`Accidents: ${d.accidents}`);
          })
          .on("mousemove", event => {
            tooltip.style("top", `${event.pageY + 10}px`).style("left", `${event.pageX + 10}px`);
          })
          .on("mouseout", () => {
            tooltip.style("visibility", "hidden");
          });

        groups.exit().remove();
      };

      d3.select("#date-picker").on("input", function () {
        const selectedDate = this.value;
        updateChart(selectedDate);
      });

      updateChart(dates[0]);
    };

    render2();
  </script> -->
  <script>
    const svg2 = d3.select("#chart");
    const margin = { top: 50, right: 30, bottom: 70, left: 60 };
    const width2 = svg2.attr("width") - margin.left - margin.right;
    const height2 = svg2.attr("height") - margin.top - margin.bottom;
  
    const g = svg2.append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);
  
    const tooltip = d3.select("body")
      .append("div")
      .attr("id", "tooltip")
      .attr("class", "tooltip");
  
    const render2 = async () => {
      const volumeData = await d3.csv("Volume_Counts.csv");
      const accidentData = await d3.csv("NYC_Collisions.csv");
  
      volumeData.forEach(d => {
        d.Boro = d.Boro;
        d.MonthYear = `${d.Yr}-${d.M.padStart(2, "0")}`;
        d.Vol = +d.Vol; // Convert volume to a number
      });
      accidentData.forEach(d => {
        d.Borough = d.Borough;
        const date = new Date(d.Date);
        const year = date.getFullYear();
        const month = `${date.getMonth() + 1}`.padStart(2, "0");
        d.MonthYear = `${year}-${month}`;
      });
  
      // Aggregate volume data
      const aggregatedVolume = d3.rollups(
        volumeData,
        v => d3.sum(v, d => d.Vol),
        d => d.Boro,
        d => d.MonthYear
      );
      console.log("Aggregated Volume Data:", aggregatedVolume);
  
      // Aggregate accident data
      const aggregatedAccidents = d3.rollups(
        accidentData,
        v => v.length,
        d => d.Borough,
        d => d.MonthYear
      );
      console.log("Aggregated Accident Data:", aggregatedAccidents);
  
      // Extract unique boroughs and months
      const boroughs = Array.from(new Set(volumeData.map(d => d.Boro)));
      const months = Array.from(new Set(volumeData.map(d => d.MonthYear))).sort();
      console.log("Boroughs:", boroughs);
      console.log("Months:", months);
  
      // Combine data for congestion and accidents
      const combinedData = boroughs.map(borough => {
        const data = months.map(monthYear => {
          // Find matching entries
          const volumeEntry = aggregatedVolume.find(([b, d]) => {
            if (b === borough && Array.isArray(d)) {
              return d.some(monthData => monthData[0] === monthYear);
            }
            return false;
          });

          const congestion = volumeEntry
            ? (volumeEntry[1].find(monthData => monthData[0] === monthYear) || [])[1] || 0
            : 0;

            const accidentEntry = aggregatedAccidents.find(([b, h]) => {
            if (b === borough && Array.isArray(h)) {
              return h.some(monthData => monthData[0] === monthYear);
            }
              return false;
            });

            const accidents = accidentEntry
            ? (accidentEntry[1].find(monthData => monthData[0] === monthYear) || [])[1] || 0
            : 0;
          // Log matching results
          console.log(`Checking Borough: ${borough}, MonthYear: ${monthYear}`);
          console.log("Volume Entry:", volumeEntry);
          console.log("Accident Entry:", accidentEntry);

          // Extract values or use 0 if no match
          // const congestion = volumeEntry ? volumeEntry[1] : 0;
          // const accidents = accidentEntry ? accidentEntry[1] : 0;

          console.log(`Borough: ${borough}, MonthYear: ${monthYear}, Congestion: ${congestion}, Accidents: ${accidents}`);

          return { monthYear, congestion, accidents };
        });
        return { borough, data };
      });

      console.log("Combined Data:", combinedData);
  
      // Populate borough selector
      const selector = d3.select("#borough-selector");
      selector.selectAll("option")
        .data(["All", ...boroughs])
        .enter()
        .append("option")
        .attr("value", d => d)
        .text(d => d.charAt(0).toUpperCase() + d.slice(1)); // Capitalize borough names
  
      // Set up date picker
      d3.select("#date-picker")
        .attr("min", months[0])
        .attr("max", months[months.length - 1])
        .property("value", months[0]);
  
      // Scales and axes
      const xScale = d3.scaleBand()
        .domain(boroughs)
        .range([10, width2])
        .padding(0.2);
  
      const xSubScale = d3.scaleBand()
        .domain(["Congestion", "Accidents"])
        .range([0, xScale.bandwidth()])
        .padding(0.1);
  
      const yScale = d3.scaleLinear().range([height2, 0]);
  
      const xAxis = g.append("g")
        .attr("transform", `translate(0, ${height2})`)
        .call(d3.axisBottom(xScale));
  
      const yAxis = g.append("g")
        .call(d3.axisLeft(yScale));
  
      g.append("text")
        .attr("class", "axis-label")
        .attr("x", width2 / 2)
        .attr("y", height2 + margin.bottom - 15)
        .attr("text-anchor", "middle")
        .text("Borough");
  
      g.append("text")
        .attr("class", "axis-label")
        .attr("x", -height2 / 2)
        .attr("y", -margin.left + 12)
        .attr("transform", "rotate(-90)")
        .attr("text-anchor", "middle")
        .text("Volume of Cars");
  
      const updateChart = selectedMonthYear => {
        const selectedBorough = selector.property("value");
        console.log("Selected Borough:", selectedBorough);
        console.log("Selected MonthYear:", selectedMonthYear);
  
        let filteredData = combinedData;
        if (selectedBorough !== "All") {
          filteredData = combinedData.filter(d => d.borough === selectedBorough);
        }
  
        console.log("Filtered Data:", filteredData);
  
        const scalingFactor = 100;
        const dataToDisplay = filteredData.map(({ borough, data }) => {
          const monthData = data.find(d => d.monthYear === selectedMonthYear) || {};
          return {
            borough,
            congestion: (monthData.congestion || 0) / scalingFactor,
            accidents: monthData.accidents || 0
          };
        });
  
        yScale.domain([0, d3.max(dataToDisplay, d => Math.max(d.congestion, d.accidents))]);
        yAxis.transition().call(d3.axisLeft(yScale).ticks(5));
  
        const groups = g.selectAll(".bar-group")
          .data(dataToDisplay, d => d.borough);
  
        const enterGroups = groups.enter()
          .append("g")
          .attr("class", "bar-group")
          .attr("transform", d => `translate(${xScale(d.borough)}, 0)`);
  
        enterGroups.append("rect")
          .merge(groups.select(".congestion-bar"))
          .attr("class", "bar congestion-bar")
          .attr("x", d => xSubScale("Congestion"))
          .attr("y", d => yScale(d.congestion))
          .attr("width", xSubScale.bandwidth())
          .attr("height", d => height2 - yScale(d.congestion))
          .attr("fill", "#1f77b4")
          .on("mouseover", (event, d) => {
            tooltip.style("visibility", "visible")
              .text(`Congestion (scaled): ${d.congestion * scalingFactor}`);
          })
          .on("mousemove", event => {
            tooltip.style("top", `${event.pageY + 10}px`).style("left", `${event.pageX + 10}px`);
          })
          .on("mouseout", () => {
            tooltip.style("visibility", "hidden");
          });
  
        enterGroups.append("rect")
          .merge(groups.select(".accidents-bar"))
          .attr("class", "bar accidents-bar")
          .attr("x", d => xSubScale("Accidents"))
          .attr("y", d => yScale(d.accidents))
          .attr("width", xSubScale.bandwidth())
          .attr("height", d => height2 - yScale(d.accidents))
          .attr("fill", "#d62728")
          .on("mouseover", (event, d) => {
            tooltip.style("visibility", "visible")
              .text(`Accidents: ${d.accidents}`);
          })
          .on("mousemove", event => {
            tooltip.style("top", `${event.pageY + 10}px`).style("left", `${event.pageX + 10}px`);
          })
          .on("mouseout", () => {
            tooltip.style("visibility", "hidden");
          });
  
        groups.exit().remove();
      };
  
      // Event listeners for selector and date picker
      selector.on("change", () => {
        const selectedMonthYear = d3.select("#date-picker").property("value");
        updateChart(selectedMonthYear);
      });
  
      d3.select("#date-picker").on("input", function () {
        const selectedMonthYear = this.value;
        updateChart(selectedMonthYear);
      });
  
      updateChart(months[0]);
    };
  
    render2();
  </script>   
  

</body>

</html>