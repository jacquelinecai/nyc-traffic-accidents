<html>

<head>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <style>
    body {
      font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
      margin-left: 40px;
    }

    .borough {
      fill: #bdc3c7;
      stroke: #2c3e50;
      stroke-width: 1px;
    }

    .dot {
      fill: #036ffc;
      opacity: 0.7;
    }

    .highlighted {
      fill: #a8e6cf;
      stroke: #8fc5b1;
      stroke-width: 2px;
    }

    .tooltip {
      position: absolute;
      visibility: hidden;
      padding: 5px;
      background-color: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      white-space: nowrap;
    }

    .title {
      font-size: 20px;
      font-weight: bold;
      margin-top: 50px;
      margin-bottom: 10px;
    }

    .subtitle {
      margin-bottom: 20px;
    }

    select {
      margin-top: 10px;
      margin-bottom: 10px;
    }
  </style>
</head>

<body>

  <!-- First Chart: NYC Traffic Accidents -->
  <div class="title">NYC Traffic Accidents</div>
  <div class="subtitle">Interactive map showing accident locations and borough population density</div>
  <svg id="nyc-map" height="600" width="800"></svg>
  <div id="controls-traffic">
    <div>
      <label>Select Borough: </label>
      <select id="borough-select">
        <option value="all">All</option>
      </select>
    </div>
    <div>
      <label>Select Vehicle Type: </label>
      <select id="vehicle-type-select">
        <option value="all">All</option>
      </select>
    </div>
    <div>
      <label>Minimum Accidents: </label>
      <input type="range" id="min-accidents-slider" min="0" max="100" value="25">
      <span id="min-accidents-value">25</span>
    </div>
  </div>

  <!-- Second Chart: Congestion by Borough -->
  <div class="title">Congestion by Borough</div>
  <div class="subtitle">Bar chart showing congestion levels for each borough by selected time</div>
  <div id="controls-congestion">
    <div>
      <label for="time-dropdown">Select Time of Day: </label>
      <select id="time-dropdown"></select>
    </div>
  </div>
  <svg id="chart" width="900" height="500"></svg>


  <script>
    const svg = d3.select("#nyc-map");
    const width = svg.attr("width");
    const height = svg.attr("height");
    let minAccidents = 25;
    let selectedBoroughPath;

    const render = async () => {
      const boroughs = await d3.json('nyc_boroughs.topo.json');
      console.log(boroughs)
      const boroughsFeature = topojson.feature(boroughs, boroughs.objects.nyc_boroughs);
      console.log(boroughsFeature)

      const collisions = await d3.csv('NYC_Collisions.csv');

      const projection = d3.geoMercator()
        .fitSize([width, height], boroughsFeature);

      const path = d3.geoPath().projection(projection);

      d3.select("#borough-select")
        .selectAll("option.borough-option")
        .data(boroughsFeature.features)
        .join("option")
        .attr("class", "borough-option")
        .attr("value", d => d.properties.boro_name)
        .text(d => d.properties.boro_name);

      svg.selectAll(".borough")
        .data(boroughsFeature.features)
        .join("path")
        .attr("class", "borough")
        .attr("d", path)
        .on("click", function (event, d) {
          zoomToBorough(d);
        });

      const vehicleTypes = [...new Set(collisions.map(d => d['Vehicle Type']))];
      d3.select("#vehicle-type-select")
        .selectAll("option.vehicle-option")
        .data(vehicleTypes)
        .join("option")
        .attr("class", "vehicle-option")
        .attr("value", d => d)
        .text(d => d);

      const tooltip = d3.select("#tooltip");

      const updateAccidents = () => {
        const selectedVehicleType = d3.select("#vehicle-type-select").property("value");
        const filteredCollisions = collisions.filter(d =>
          (selectedVehicleType === 'all' || d['Vehicle Type'] === selectedVehicleType)
        );

        const accidentCounts = d3.rollups(
          filteredCollisions,
          v => v.length,
          d => d['Street Name']
        ).filter(([_, count]) => count >= minAccidents);

        const accidentsWithCoords = accidentCounts.map(([street, count]) => {
          const point = filteredCollisions.find(d => d['Street Name'] === street);
          if (point && point.Latitude && point.Longitude) {
            return {
              street: street,
              count: count,
              coordinates: [point.Longitude, point.Latitude]
            };
          }
        }).filter(d => d && d.count && d.coordinates);

        const dots = svg.selectAll(".dot")
          .data(accidentsWithCoords, d => d.street);

        dots.enter()
          .append("circle")
          .attr("class", "dot")
          .attr("cx", d => projection(d.coordinates)[0])
          .attr("cy", d => projection(d.coordinates)[1])
          .attr("r", d => Math.sqrt(d.count))
          .on("mouseover", function (event, d) {
            d3.select(this).style("fill", "#25d6fa");
            tooltip.style("visibility", "visible")
              .text(`Accidents: ${d.count}, Street: ${d.street}`);
          })
          .on("mousemove", function (event) {
            tooltip.style("top", `${event.pageY + 10}px`)
              .style("left", `${event.pageX + 10}px`);
          })
          .on("mouseout", function () {
            d3.select(this).style("fill", "#036ffc");
            tooltip.style("visibility", "hidden");
          });

        dots.attr("cx", d => projection(d.coordinates)[0])
          .attr("cy", d => projection(d.coordinates)[1])
          .attr("r", d => Math.sqrt(d.count));

        dots.exit().remove();
      };

      d3.select("#vehicle-type-select").on("change", updateAccidents);

      d3.select("#min-accidents-slider").on("input", function () {
        minAccidents = +this.value;
        d3.select("#min-accidents-value").text(minAccidents);
        updateAccidents();
      });

      const zoom = d3.zoom().on("zoom", (event) => {
        svg.selectAll('path').attr('transform', event.transform);
        svg.selectAll('circle').attr('transform', event.transform);
      });

      svg.call(zoom);

      const zoomToBorough = (borough, boroughPath) => {
        const [[x0, y0], [x1, y1]] = path.bounds(borough);
        const scale = 0.8 / Math.max((x1 - x0) / width, (y1 - y0) / height);
        const translate = [
          width / 2 - scale * (x0 + x1) / 2,
          height / 2 - scale * (y0 + y1) / 2
        ];

        svg.transition().duration(750).call(
          zoom.transform,
          d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
        );

        if (selectedBoroughPath) {
          selectedBoroughPath.classed("highlighted", false);
        }

        selectedBoroughPath = boroughPath;
        selectedBoroughPath.classed("highlighted", true);
      };

      d3.select("#borough-select").on("change", function () {
        const selectedBorough = this.value;
        if (selectedBorough === "all") {
          svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
          if (selectedBoroughPath) {
            selectedBoroughPath.classed("highlighted", false);
            selectedBoroughPath = null;
          }
        } else {
          const borough = boroughsFeature.features.find(b => b.properties.boro_name === selectedBorough);
          const boroughPath = svg.selectAll(".borough").filter(d => d.properties.boro_name === selectedBorough);
          if (borough) zoomToBorough(borough, boroughPath);
        }
      });

      updateAccidents();
    };

    render();
  </script>


  <script>
    const svg2 = d3.select("#chart");
    const margin = { top: 50, right: 30, bottom: 70, left: 60 }; // Increased bottom margin for borough labels
    const width2 = svg2.attr("width") - margin.left - margin.right;
    const height2 = svg2.attr("height") - margin.top - margin.bottom;

    const g = svg2.append("g").attr("transform", `translate(${margin.left}, ${margin.top})`);

    const tooltip = d3.select("body").append("div").attr("class", "tooltip");

    const render2 = async () => {
      const data = await d3.csv("Volume_Counts.csv");

      data.forEach(d => {
        d.HH = +d.HH; // Hour
        d.Vol = +d.Vol; // Volume
      });

      const aggregatedData = d3.rollups(
        data,
        v => d3.sum(v, d => d.Vol),
        d => d.Boro,
        d => d.HH
      );

      const boroughs = Array.from(new Set(data.map(d => d.Boro)));
      const hours = Array.from(new Set(data.map(d => d.HH))).sort((a, b) => a - b);

      const dropdown = d3.select("#time-dropdown");
      dropdown.selectAll("option")
        .data(hours)
        .join("option")
        .attr("value", d => d)
        .text(d => `${d}:00`);

        const xScale = d3.scaleBand()
  .domain(boroughs)
  .range([10, width2]) // Add 10px padding at the start
  .padding(0.2);

      const yScale = d3.scaleLinear()
        .range([height2, 0]);

      const xAxis = g.append("g")
        .attr("transform", `translate(0, ${height2})`)
        .call(d3.axisBottom(xScale));

      const yAxis = g.append("g")
        .call(d3.axisLeft(yScale));

      g.append("text")
        .attr("class", "axis-label")
        .attr("x", width2 / 2)
        .attr("y", height2 + margin.bottom - 15) 
        .attr("text-anchor", "middle") 
        .text("Borough");

      // Add Y-axis label
      g.append("text")
        .attr("class", "axis-label")
        .attr("x", -height2 / 2) 
        .attr("y", -margin.left +12)
        .attr("transform", "rotate(-90)") 
        .attr("text-anchor", "middle")
        .text("Volume (Congestion)");

      const updateChart = hour => {
        const filteredData = aggregatedData.map(([borough, hours]) => {
          const hourData = hours.find(([h]) => h === hour);
          return { Boro: borough, Vol: hourData ? hourData[1] : 0 };
        });

        yScale.domain([0, d3.max(filteredData, d => d.Vol)]);

        yAxis.transition().call(d3.axisLeft(yScale).ticks(5));

        const bars = g.selectAll(".bar")
          .data(filteredData, d => d.Boro);

        bars.join("rect")
          .attr("class", "bar")
          .attr("x", d => xScale(d.Boro))
          .attr("y", d => yScale(d.Vol))
          .attr("width", xScale.bandwidth())
          .attr("height", d => height2 - yScale(d.Vol))
          .attr("fill", d => {
            if (d.Boro === "Manhattan") return "#1f77b4"; // Blue
            if (d.Boro === "Brooklyn") return "#ff7f0e"; // Orange
            if (d.Boro === "Queens") return "#2ca02c"; // Green
            if (d.Boro === "Bronx") return "#d62728"; // Red
            if (d.Boro === "Staten Island") return "#9467bd"; // Purple
            return "#ccc"; // Default color
          })
          .on("mouseover", (event, d) => {
            tooltip.style("visibility", "visible")
              .text(`Borough: ${d.Boro}, Volume: ${d.Vol}`);
          })
          .on("mousemove", event => {
            tooltip.style("top", `${event.pageY + 10}px`).style("left", `${event.pageX + 10}px`);
          })
          .on("mouseout", () => {
            tooltip.style("visibility", "hidden");
          });

        bars.transition()
          .attr("x", d => xScale(d.Boro))
          .attr("y", d => yScale(d.Vol))
          .attr("height", d => height2 - yScale(d.Vol));

        bars.exit().remove();
      };

      dropdown.on("change", function () {
        const selectedHour = +this.value;
        updateChart(selectedHour);
      });

      updateChart(hours[0]);
    };

    render2();
  </script>


</body>

</html>